    2ЛАБОРАТОРНАЯ РАБОТА 6.
    2АЛГОРИТМЫ ПОИСКА И СОРТИРОВКИ: временная эффективность

 ш1.0
                               1Главное прыгнуть с обрыва - по пути у
                               1вас обязательно вырастут крылья. 0
                                                    1Автор неизвестен
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Основные понятия . 0:
 ш1.0
    1- асимптотические  оценки  алгоритмов  поиска элемента массива и
 1сортировки элементов в массиве 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   - ...;
   - ....
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                          3Основные понятия
   Пусть для решения одной и той же задачи имеется несколько  алго-
ритмов и необходимо решить,  какой из них "лучше". Это вводит нас в
область  _ 1анализа алгоритмов . 0:  по заданному алгоритму найти его рабо-
чие характеристики.
   Напомним, что в  _ 1теории алгоритмов . 0 речь идет лишь о  1существовании
или  1несуществовании 0 алгоритмов.
    1М 0. 1Рабин 0 предложил перечень вопросов, интересующих исследователя,
занимающегося  _ 1анализом алгоритмов . 0 [Лекции,1993,с.379]:
 ш1.1
   (1) поискать точные решения задачи P;
   (2) поискать программно-реализованные (возможно, и аппаратно-ре-
ализованные) алгоритмы решения задачи P;
   (3) найти последовательный алгоритм для решения задачи P;
   (4) установить оценку сложности для наилучшего случая;
   (5) установить оценку сложности для наихудшего случая;
   (6) установить оценку сложности для среднего случая;
   (7) найти более эффективные алгоритмы для решения задачи P;
   (8) найти параллельный алгоритм для решения задачи P;
   (9) найти алгоритм для нахождения приближённых решений P;
   (10) найти вероятностный алгоритм для решения задачи P.

 ш1.2
    1Целью  0раздела "Анализ алгоритмов" является знакомство  студентов
с  методами  разработки алгоритмов и основными принципами оценки их
эффективности, которая производится с точки зрения затрат ресурсов,
необходимых исполнителю для его реализации.
   Если в  качестве исполнителя выступает компьютер,  то в качестве
таких ресурсов выступают  1обьём памяти 0,  необходимой для  размещения
команд алгоритма и обрабатываемых данных, и  1время 0, затрачиваемое на
исполнение алгоритма.
   Как правило,  эти  ресурсы бывают связаны сложной зависимостью и
задача разработчика алгоритма состоит в том,  чтобы найти  разумный
компромисс между используемым объёмом памяти и временем исполнения.
   Так,  1Стивен А.Кук 0 [Лекции,1993,с.477] в Тьюринговской лекции го-
ворит: "Опираясь на двадцатилетний опыт, я теперь считаю очевидным,
что время и объём памяти - особенно время - находятся в ряду наибо-
лее существенных мер сложности.  Представляется, что при оценке эф-
фективности алгоритма в первую очередь принимается в  расчёт  время
его  выполнения...  Очень важным является вопрос о том,  что именно
является правильной моделью компьютера для измерения времени работы
алгоритма. Обычно в литературе используют многоленточные машины Ть-
юринга..."
   Таким образом, пространственная и временная сложности (как функ-
ции от размеров задачи) являются  двумя  фундаментальными  оценками
эффективности при анализе алгоритмов.  Более того, улучшение харак-
теристик  компьютера (быстродействие,  объём памяти) не снижает,  а
напротив, повышает требования к качеству  алгоритмов,  а  повышение
эффективности  алгоритмов  зачастую дает лучший результат,  чем ис-
пользование более мощного компьютера.
   Анализ различных  вариантов одного и того же алгоритма позволяет
выбрать для решения задачи наиболее  подходящий  вариант  с  учётом
имеющихся в распоряжении ресурсов конкретного исполнителя (структур
данных). Вот почему важно познакомиться с примерами анализа и оцен-
ки наиболее распространённых алгоритмов, связанных с  1задачами поис-
 1ка и сортировки данных 0,   1генерации случайных чисел 0,  1генерацией ком-
 1бинаторных объектов, 0  1теорией чисел 0,  1деревьями 0,  1графами 0 и т.п.
   Так,  1Стивен А.Кук 0 [Лекции,1993,с.379] отмечает: "Наиболее важные
алгоритмы (с точки зрения вычислительной сложности) должны  быть  в
некотором смысле особенными;  они в основном дают удивительно быст-
рый способ решения какой-нибудь простой или важной задачи".
   Содержание раздела " _ 1Анализ алгоритмов . 0" существенным образом  ос-
новывается на работах  1Д.Кнута 0 [1976,1977,1978; Грин,Кнут,1987].
   В основу содержания раздела " 1Анализ алгоритмов 0" обычно включают-
ся следующие темы:
 ш1.1
   (1) рекуррентные уравнения и методы их решения;
   (2) оценка эффективности алгоритмов поиска и сортировки;
   (3) анализ комбинаторных алгоритмов;
   (4) алгоритмы генерации случайных чисел и их анализ;
   (5) анализ простейших алгоритмов теории чисел;
   (6) анализ алгоритмов работы с деревьями и графами.

 ш1.2
   Материал курса  имеет теоретический характер и строится с опорой
на формальные математические методы; в частности, методы нахождения
 _ 1асимптотической  сложности алгоритмов . 0 основаны на широком использо-
вании результатов:
 ш1.1
   -  _ 1математического анализа . 0 (теория пределов, интегралы, связь ин-
тегралов с суммами, гармонические числа);
   -  _ 1теории вероятностей . 0 (случайные величины, математическое ожида-
ние, дисперсия, среднее квадратическое отклонение).

 ш1.2
   Прикладное же значение курса состоит  в  том,  что  он  помогает
программистам выбрать и использовать в практической работе наиболее
эффективные алгоритмы.

                     2Алгоритмы поиска в массиве

 ш1.0
                                1Всё 0  1испытывайте, хорошего держитесь.
                                                         11 Фес, 5 0: 121
 ш1.2
                                ...


                   2Алгоритмы сортировки в массиве
                  21.  3Алгоритм сортировки подсчётом

 ш1.0
               1Сколько ни перечислять всё то, что он знает, - сказал
               1я себе,  - невозможно догадаться,  для чего  ему  это
               1нужно  и  что  за профессия требует такого сочетания 0!
               1Нет, лучше уж не ломать себе голову понапрасну 0!
                                 1А.Конан Дойл. Этюд в багровых тонах
 ш1.2

   Вначале для  каждого  элемента массива подсчитывается количество
элементов, меньших,  чем он,  и на основе этой  информации  текущий
элемент помещается в соответствующее место отсортированного массива.
   Приведём алгоритм на  1псевдокоде 0 [Левитин,2006,с.52]:
 ш1.0

   // Сортировка массива методом подсчёта сравнений.
   // Входные данные: массив чисел A[0..n-1], который требуется
   //                 отсортировать.
   // Выходные данные: массив чисел S[0..n-1], состоящий из элемен-
   //                  тов массива A, отсортированных  в  неубываю-
   //                  щем порядке
   // ----------------------------
   for i:=0 to n-1 do
      Count[i]:=0
   for i:=0 to n-2 do
      for j:=i+1 to n-1 do
         if A[i]<A[j]
           Count[j]:=Count[j]+1
         else Count[i]:=Count[i]+1
   for i:=0 to n-1 do
      S[Count[i]]:=A[i]
   return S

 ш1.2
   Какова же временная эффективность данного алгоритма?
   Она должна  быть квадратичной,  поскольку алгоритм рассматривает
все различные пары n-элементного массива.  Более строго, количество
выполнений базовой операции сравнения A[i]<A[j] равно
 ш1.0

    5n-2 0   5n-1 0    5n-2 0               5n-2
    7░▒ 0    7░▒ 0     7░▒ 0                7░▒ 0          (n-1) 77 0n
     7▓  0    7▓ 0 1 =  7▓  0(n-1-(i+1)+1)=  7▓  0(n-1+i)= ───────  7еQ 0(n 52 0).
    7│┤ 0    7│┤ 0     7│┤ 0                7│┤ 0             2
    4i=0 j=i+1 0   4i=0 0               4i=0

 ш1.2
   Поскольку алгоритм  выполняет то же количество сравнений ключей,
что и алгоритм сортировки выбором, и при  этом  требуется  линейное
количество дополнительной  памяти,  его  трудно  рекомендовать  для
практического применения.
                  22. 0  3Алгоритм сортировка подсчётом
                            3распределения
   Однако идея  подсчёта хорошо работает в ситуации,  когда нам из-
вестны  1минимальный 0 элемент сортируемого массива (обозначим его  1l 0) и
 1максимальный 0 элемент сортируемого массива (обозначим его  1u 0).
   Элементы массива будем копировать в новый массив S[0..n-1].
   При этом те элементы A, значения ключей которых равны наименьше-
му возможному значению 1 l 0,  копируются в первые  F[0]  элементов  S,
т.е. в позиции от 0 до F[0]-1,  элементы со значением ключа  1l 0+1 - в
позиции от F[0] до F[0]+F[1]-1 и т.д. поскольку такие накапливаемые
суммы частот  в статистике называются  1распределением 0,  то описанный
метод называется  _ 1сортировкой подсчётом распределений . 0.
   Приведём алгоритм на псевдокоде [Левитин,2006,с.309-310]:
 ш1.0

   // Сортировка массива целых чисел из ограниченного диапазона
   // при помощи сортировки подсчётом распределения.
   // Входные данные: массив A[0..n-1] целых чисел, расположенных
   //                 между 1 l 0 и  1u 0 ( 1l 7, 1u 0).
   // Выходные данные: массив чисел S[0..n-1], состоящий из элемен-
   //                  тов массива A, отсортированных  в  неубываю-
   //                  щем порядке
   // ------------------------------------------------------
   for j:=0 to  1u 0- 1l 0 do        // Инициализация массива частот
      D[j]:=0
   for i:=0 to n-1 do        // Вычисление частот
      D[A[i]- 1l 0]:=D[A[i]- 1l 0]+1
   for j:=1 to  1u 0- 1l 0 do        // Получение распределения
      D[j]:=D[j-1]+D[j]
   for i:=n-1 downto 0 do
      j:=A[i]- 1l
      S[D[j]-1]:=A[i]
      D[j]:=D[j]-1
   return S

 ш1.2
   В предположении фиксированного диапазона значений очевидно,  что
этот алгоритм линеен, поскольку выполняет два последовательных про-
хода по  входному массиву A.  Эффективность этого алгоритма гораздо
выше, чем у таких алгоритмов сортировки,  как слиянием,  быстрой  и
пирамидальной. Однако важно помнить, что эта эффективность получена
благодаря конкретному виду входных  данных,  для  которых  работает
сортировка подсчётом  распределения  (помимо использования дополни-
тельной памяти).

                 3Временная эффективность 0  3алгоритмов
                          3поиска 0  3в массиве
   В таблице  показаны приближённые  _ 1оценки сложности алгоритмов по-
 _ 1иска в массиве . 0 (в наихудшем и наилучшем вариантах).
 ш1.0

                    ╓───────────────────┬─────────────────┐
                    ║  3Наихудший вариант 0 │  3Средний вариант 0 │
   ┌──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Линейный поиск   0║        7O 0(n) 1  0       │       7O 0(n)  1  0     │
   ├──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Бинарный поиск   0║      7O 0( 1log 42 0n)      │     7O 0( 1log 42 0n)     │
   ├──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Интерполяционный 0║     1  0  1  7O 0(n)  1   0     │   7O 0( 1log 42 1log 42 0n)   │
    1│поиск            0║ 1                 0   1 │   0   1             │
   └──────── 1── 0──────╨───────────────────┴─────────────────┘

 ш1.2
   При анализе  1наихудшего варианта 0 оценивают максимальный объём ра-
боты,  необходимой для решения задачи заданного размера, а при ана-
лизе  1среднего варианта 0 - вероятный объём работы.
   Таким образом, бинарный поиск намного лучше линейного.
   Например,  1log 42 01000000=19,  поэтому алгоритм линейного поиска вы-
полнит миллион сравнений,  в то время как алгоритм бинарного поиска
- не более 20.  Если размерность массива велика,  то бинарный поиск
намного эффективнее линейного. Однако следует иметь в виду, что ус-
ловие упорядоченности массива приводит к  дополнительным  затратам,
которые могут быть существенными.
   Сравним, например,  эффективность алгоритмов линейного поиска  и
бинарного поиска в массиве.  Очевидно, что при количестве элементов
в массиве, равном 100000, получается выигрыш примерно в 6000 раз.
 ш1.0

                      ╓─────────────────────────────┐
                      ║      3Количество операций 0     │
   ┌──────────────────╫────────┬────────────────────┤
   │ 1Количество элемен- 0║ 1Линейный 0│       1Бинарный  0     │
   │ 1тов в массиве 0    1   0║  1поиск 0  │        1поиск 0        │
   ╞══════════════════╬════════╪════════════════════╡
   │          10      ║     10 │  1log 42 0(    10) 7~ 0 3.32 │
   │         100      ║    100 │  1log 42 0(   100) 7~ 0 6.64 │
   │        1000      ║   1000 │  1log 42 0(  1000) 7~ 0 9.96 │
   │       10000      ║  10000 │  1log 42 0( 10000) 7~ 013.28 │
   │      100000      ║ 100000 │  1log 42 0(100000) 7~ 016.06 │
   └──────────────────╨────────┴────────────────────┘
 ш1.2

                 3Временная эффективность 0  3алгоритмов
                         3сортировки 0  3массивов

 ш1.0
                      1... задача, стоящая перед программистом, - это
                      1интеллектуальный вызов высочайшего ранга.
                                                          1Э.Дейкстра
 ш1.2

    _ 1Сортировка обменами . 0: количество сравнений
 ш1.0

    5n-2 0  5n-2-i
    7░▒ 0   7░▒ 0     (n-1) 77 0n
     7▓  0   7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0   7│┤ 0        2
    4i=0 j=0

 ш1.2
   Количество обменов для наихудшего случая равно
 ш1.0

   (n-1) 77 0n
   ───────  7еQ 0(n 52 0).
      2

 ш1.2
    _ 1Сортировка выбором . 0: количество сравнений
 ш1.0

    5n-2 0   5n-1
    7░▒ 0    7░▒ 0     (n-1) 77 0n
     7▓  0    7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0    7│┤ 0        2
    4i=0 j=i+1

 ш1.2
    _ 1Сортировка вставками . 0: количество сравнений для худшего случая
 ш1.0

    5n-1 0  5i-1
    7░▒ 0   7░▒ 0     (n-1) 77 0n
     7▓  0   7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0   7│┤ 0        2
    4i=1 j=0

 ш1.2
   Для уже  отсортированного  массива  количество  сравнений  равно
n-1 7еQ 0(n), а при работе со  1случайными массивами 0  среднее  количество
сравнений равно n 52 0/4 7еQ 0(n 52 0).
   В таблице (см. [Каррано,Причард,2003,с.447]) показаны приближён-
ные  _ 1оценки сложности алгоритмов сортировки . 0 (в наихудшем и наилучшем
вариантах).
 ш1.0

                               ╓─────────────────┬───────────────┐
                               ║ 3Наихудший вариант 0│ 3Средний вариант 0│
  ┌─────────────────────────── 1─ 0╫─────────────────┼───────────────┤
  │ 1Сортировка обменами  0        1  0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка выбором           0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка включениями 0      ║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Быстрая сортировка           0║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка слиянием 0        1  0 ║     7O 0(n 77 1log 0(n))  │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка подсчётом 0        ║                 │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка подсчётом 0  1распре- 0║       7O 0(n)       │      7O 0(n)      │
  │ 1деления 0                     ║                 │               │
  ╞════════════════════════════╬═════════════════╪═══════════════╡
  │Пирамидальная сортировка   1  0 ║     7O 0(n 77 1log 0(n))  │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │Поразрядная сортировка     1  0 ║       7O 0(n)       │      7O 0(n)      │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │Сортировка с помощью дерева ║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
  └────────────────────────── 1─ 0─╨─────────────────┴───────────────┘

 ш1.2
   При анализе  1наихудшего варианта 0 оценивают максимальный объём ра-
боты,  необходимой для решения задачи заданного размера, а при ана-
лизе  1среднего варианта 0 - вероятный объём работы.
    3Предупреждения 2  0[Каррано,Причард,2003,с.448].
 ш1.1
    21. 0 Если  размер  задачи  невелик,  не стоит вообще анализировать
сложность алгоритма.  В этом случае основным фактором является  его
 1простота 0. Так, для сортировки массива, содержащего не более 25 эле-
ментов вполне подходит простой алгоритм сортировки включениями, хо-
тя его сложность  7O 0(n 52 0).
    22. 0 При  сортировке  очень большого массива алгоритмы,  сложность
которых оценивается величиной  7O 0(n 52 0), не эффективны.
    23. 0 Алгоритм  быстрой  сортировки  следует выбирать,  только если
элементы массива расположены в произвольном порядке.
   Несмотря на то,  что в худшем случае сложность алгоритма быстрой
сортировки оценивается величиной  7O 0(n 52 0),  на практике такая ситуация
встречается крайне редко.
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                              1Если я не буду протирать звёзды каждый
                              1вечер, они обязательно потускнеют. 0
                                              1Из м/ф "Ёжик в тумане"
 ш1.2

                    21. 3 Алгоритмы поиска в массиве
    21. 0 [Поляков,Ерёмин,2013,ч.2,с.34]
   Предложите алгоритм, позволяющий найти и вывести на экран те сим-
волы, которые встречаются в строке более одного раза.
    22. 0 (По [Поляков,Ерёмин,2013,ч.2,с.34])
   Оцените количество операций для алгоритмов:
 ш1.1
   (а) поиска всех делителей числа;
   (б) проверки числа на простоту.
   (в) нахождения минимального и максимального элементов массива;
   (г) определения количества положительных элементов массива;

 ш1.2
    23. 0 [Рафгарден,2019,с.127]
   Дан  1унимодулярный массив 0 из n различных элементов, что означает,
что его элементы находятся в строго возрастающем порядке до  своего
максимального элемента,  после чего его элементы находятся в строго
убывающем порядке.  Разработайте алгоритм вычисления  максимального
элемента унимодального массива, выполняющийся за время  7O 0( 1log 0(n)).
    24. 0 [Рафгарден,2019,с.127]
   Дан отсортированный  (от  наименьшего  до  наибольшего элемента)
массив A из n разных целых чисел, которые могут быть  положительны-
ми, отрицательными или нулевыми. Определите, существует ли индекс i
такой, что A[i]=i.  Разработайте самый быстрый алгоритм для решения
этой задачи.
    25. 0 (По [Левитин,2006,с.98])
   Вы подошли вплотную к стене, не имеющей ни начала, ни конца.
   Известно, что  в стене есть дверь,  но вы не знаете в каком нап-
равлении и как долго нужно двигаться,  чтобы найти эту дверь. Заме-
тить  дверь  в стене можно,  только подойдя непосредственно к ней и
став напротив.
   Разработайте алгоритм,  который позволяет находить дверь в стене
методом обхода не более чем за  7O 0(n) шагов,  где n - неизвестное за-
ранее число шагов между вашим первоначальным положением и дверью.
                  22. 3 Алгоритмы сортировки массивов
    21. 0 (По [Левитин,2006,с.310-311])
    _ 1Задача о Российском флаге . 0. Переставьте элементы массива символов
К, С,  Б,  означающих красный, синий и белый цвета флага, так чтобы
первыми шли символы Б, затем - С, а последними - К.
   Разработайте алгоритм,  решающий поставленную задачу за линейное
время без привлечения дополнительной памяти.
    22. 0 (По [Поляков,Ерёмин,2013,ч.2,с.33-34])
   Напишите программу реализации алгоритма  _ 1сортировки подсчётом . 0.
                       23. 0  3Контрольные задания
    21. 0 [Поляков,Ерёмин,2013,ч.2,с.34]
   Алфавит языка племени "тумба-юмба" содержит k символов.
   Предложите алгоритм построения всех возможных слов  этого  языка,
имеющих длину n символов, и оцените его асимптотическую сложность.
